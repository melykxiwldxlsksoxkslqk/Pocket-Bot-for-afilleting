/* tslint:disable */
/* eslint-disable */

/* auto-generated by NAPI-RS */

/**
 * Initializes the logging system with the specified configuration.
 *
 * # Arguments
 * * `path` - Directory path where log files will be stored
 * * `level` - Logging level ("DEBUG", "INFO", "WARN", "ERROR")
 * * `terminal` - Whether to output logs to terminal
 * * `layers` - Additional logging layers for custom log handling
 *
 * # Examples
 * ```javascript
 * const { startTracing } = require('binary-options-tools');
 *
 * // Initialize logging with DEBUG level and terminal output
 * startTracing('./logs', 'DEBUG', true, []);
 * ```
 */
export declare function startTracing(path: string, level: string, terminal: boolean, layers: Array<StreamLogsLayer>): void
/**
 * Iterator for receiving processed WebSocket messages.
 * Provides asynchronous iteration over parsed messages from the server.
 *
 * # Examples
 * ```javascript
 * const stream = await client.subscribeSymbol('EUR/USD');
 * for await (const price of stream) {
 *     console.log('Current price:', price);
 * }
 * ```
 */
export declare class StreamIterator {
  /**
   * Gets the next price update from the stream.
   *
   * # Returns
   * * A Promise that resolves to:
   *   * A JSON string containing the next price update data
   *   * null if the stream has ended
   * * Rejects with an error if the stream encounters an error
   *
   * # Examples
   * ```javascript
   * const stream = await client.subscribeSymbol('EUR/USD');
   *
   * // Using async/await
   * try {
   *     while (true) {
   *         const update = await stream.next();
   *         if (update === null) break;
   *         const data = JSON.parse(update);
   *         console.log('Price:', data.price);
   *     }
   * } catch (err) {
   *     console.error('Stream error:', err);
   * }
   * ```
   */
  next(): Promise<any | null>
}
/**
 * Iterator for receiving raw WebSocket messages.
 * Provides asynchronous iteration over raw messages from the server.
 *
 * # Examples
 * ```javascript
 * const stream = await client.createRawIterator();
 * for await (const message of stream) {
 *     console.log('Raw message:', message);
 * }
 * ```
 */
export declare class RawStreamIterator {
  /**
   * Gets the next raw WebSocket message from the stream.
   *
   * # Returns
   * * A Promise that resolves to:
   *   * A string containing the raw WebSocket message
   *   * null if the stream has ended
   * * Rejects with an error if the stream encounters an error
   *
   * # Examples
   * ```javascript
   * const stream = await client.createRawIterator(
   *     JSON.stringify({ type: 'subscribe' }),
   *     validator
   * );
   *
   * // Using async/await
   * try {
   *     while (true) {
   *         const message = await stream.next();
   *         if (message === null) break;
   *         console.log('Raw message:', message);
   *     }
   * } catch (err) {
   *     console.error('Stream error:', err);
   * }
   *
   * // Using for-await-of
   * try {
   *     for await (const message of stream) {
   *         console.log('Raw message:', message);
   *     }
   * } catch (err) {
   *     console.error('Stream error:', err);
   * }
   * ```
   */
  next(): Promise<string | null>
}
/**
 * A client for interacting with the Pocket Option trading platform.
 * Provides methods for executing trades, managing positions, and streaming market data.
 *
 * # Examples
 * ```javascript
 * const client = new PocketOption("your-ssid-here");
 *
 * // Execute a buy order
 * const [orderId, details] = await client.buy("EUR/USD", 100, 60);
 *
 * // Check trade result
 * const result = await client.checkWin(orderId);
 * ```
 */
export declare class PocketOption {
  /**
   * Creates a new PocketOption client instance using a session ID.
   *
   * # Arguments
   * * `ssid` - A valid session ID string from Pocket Option
   *
   * # Examples
   * ```javascript
   * const client = new PocketOption("your-ssid-here");
   * ```
   */
  constructor(ssid: string)
  /**
   * Creates a new PocketOption client instance with a custom WebSocket URL.
   *
   * # Arguments
   * * `ssid` - A valid session ID string from Pocket Option
   * * `url` - Custom WebSocket server URL
   *
   * # Examples
   * ```javascript
   * const client = await PocketOption.newWithUrl(
   *     "your-ssid-here",
   *     "wss://custom-server.com/ws"
   * );
   * ```
   */
  static newWithUrl(ssid: string, url: string): Promise<PocketOption>
  /**
   * Checks if the current account is a demo account.
   *
   * # Returns
   * * `true` if the account is a demo account
   * * `false` if the account is a real account
   *
   * # Examples
   * ```javascript
   * // Check account type
   * const isDemo = await client.isDemo();
   * if (isDemo) {
   *     console.log("Using demo account");
   * } else {
   *     console.log("Using real account");
   * }
   *
   * // Example with balance check
   * const isDemo = await client.isDemo();
   * const balance = await client.balance();
   * console.log(`${isDemo ? 'Demo' : 'Real'} account balance: ${balance}`);
   *
   * // Example with trade validation
   * const isDemo = await client.isDemo();
   * if (!isDemo && amount > 100) {
   *     throw new Error("Large trades should be tested in demo first");
   * }
   * ```
   */
  isDemo(): Promise<boolean>
  /**
   * Executes a buy (CALL) order for a specified asset.
   *
   * # Arguments
   * * `asset` - The trading asset/symbol (e.g., "EUR/USD")
   * * `amount` - The trade amount in account currency
   * * `time` - The option duration in seconds
   *
   * # Returns
   * A vector containing the order ID and order details as JSON
   *
   * # Examples
   * ```javascript
   * const [orderId, details] = await client.buy("EUR/USD", 100, 60);
   * console.log(`Order placed: ${orderId}`);
   * console.log(`Details: ${details}`);
   * ```
   */
  buy(asset: string, amount: number, time: number): Promise<Array<any>>
  /**
   * Executes a sell (PUT) order for a specified asset.
   *
   * # Arguments
   * * `asset` - The trading asset/symbol (e.g., "EUR/USD")
   * * `amount` - The trade amount in account currency
   * * `time` - The option duration in seconds
   *
   * # Returns
   * A vector containing the order ID and order details as JSON
   *
   * # Examples
   * ```javascript
   * const [orderId, details] = await client.sell("EUR/USD", 100, 60);
   * console.log(`Order placed: ${orderId}`);
   * console.log(`Details: ${details}`);
   * ```
   */
  sell(asset: string, amount: number, time: number): Promise<Array<any>>
  /**
   * Checks the result of a trade by its ID.
   *
   * # Arguments
   * * `trade_id` - The UUID of the trade to check
   *
   * # Returns
   * A JSON string containing the trade result details
   *
   * # Examples
   * ```javascript
   * const result = await client.checkWin(tradeId);
   * const details = JSON.parse(result);
   * console.log(`Profit: ${details.profit}`);
   * ```
   */
  checkWin(tradeId: string): Promise<any>
  /**
   * Gets the expiration timestamp of a trade.
   *
   * # Arguments
   * * `trade_id` - The UUID of the trade
   *
   * # Returns
   * The Unix timestamp when the trade will expire, or null if not found
   *
   * # Examples
   * ```javascript
   * const endTime = await client.getDealEndTime(tradeId);
   * if (endTime) {
   *     console.log(`Trade expires at: ${new Date(endTime * 1000)}`);
   * }
   * ```
   */
  getDealEndTime(tradeId: string): Promise<number | null>
  /**
   * Retrieves historical candle data for an asset.
   *
   * # Arguments
   * * `asset` - The trading asset/symbol (e.g., "EUR/USD")
   * * `period` - The candle period in seconds
   * * `offset` - Time offset for historical data
   *
   * # Returns
   * A JSON string containing the candle data
   *
   * # Examples
   * ```javascript
   * const candles = await client.getCandles("EUR/USD", 60, 6000);
   * const data = JSON.parse(candles);
   * console.log(`Retrieved ${data.length} candles`);
   * ```
   */
  getCandles(asset: string, period: number, offset: number): Promise<any>
  /**
   * Retrieves the current account balance.
   *
   * # Returns
   * A f64 representing the account balance
   *
   * # Examples
   * ```javascript
   * const balance = await client.balance();
   * console.log(`Current balance: ${balance}`);
   * ```
   */
  balance(): Promise<number>
  /**
   * Retrieves all closed deals/trades.
   *
   * # Returns
   * A JSON string containing the closed deals information
   *
   * # Examples
   * ```javascript
   * const deals = await client.closedDeals();
   * const data = JSON.parse(deals);
   * console.log(`Total closed deals: ${data.length}`);
   * ```
   */
  closedDeals(): Promise<any>
  /**
   * Clears the list of closed deals from memory.
   *
   * # Examples
   * ```javascript
   * await client.clearClosedDeals();
   * ```
   */
  clearClosedDeals(): Promise<void>
  /**
   * Retrieves all currently open deals/trades.
   *
   * # Returns
   * A JSON string containing the open deals information
   *
   * # Examples
   * ```javascript
   * const deals = await client.openedDeals();
   * const data = JSON.parse(deals);
   * console.log(`Total open positions: ${data.length}`);
   * ```
   */
  openedDeals(): Promise<any>
  /**
   * Retrieves the current payout rates for assets.
   *
   * # Arguments
   * * `asset` - Optional parameter that can be:
   *   * `undefined`: Returns all asset payouts (default)
   *   * `string`: Returns payout for a specific asset
   *   * `string[]`: Returns payouts for multiple assets
   *
   * # Returns
   * A JSON value containing the payout information:
   * * When no asset specified: Object mapping assets to payout percentages
   * * When single asset specified: Number representing payout percentage
   * * When multiple assets specified: Array of payout percentages in same order
   *
   * # Examples
   * ```javascript
   * // Get all payouts
   * const allPayouts = await client.payout();
   * console.log("All payouts:", allPayouts);
   * // Output: { "EUR/USD": 85, "GBP/USD": 82, ... }
   *
   * // Get single asset payout
   * const eurUsdPayout = await client.payout("EUR/USD");
   * if (eurUsdPayout !== null) {
   *     console.log(`EUR/USD payout: ${eurUsdPayout}%`);
   * } else {
   *     console.log("Asset not found");
   * }
   *
   * // Get multiple asset payouts
   * const assets = ["EUR/USD", "GBP/USD", "USD/JPY"];
   * const payouts = await client.payout(assets);
   * assets.forEach((asset, index) => {
   *     const rate = payouts[index];
   *     if (rate > 0) {
   *         console.log(`${asset} payout: ${rate}%`);
   *     } else {
   *         console.log(`${asset} not available`);
   *     }
   * });
   *
   * // Find best payout
   * const rates = await client.payout();
   * const bestAsset = Object.entries(rates)
   *     .reduce((a, b) => a[1] > b[1] ? a : b);
   * console.log(`Best payout: ${bestAsset[0]} at ${bestAsset[1]}%`);
   * ```
   */
  payout(asset?: string | Array<string> | undefined | null): Promise<any>
  /**
   * Retrieves historical data for an asset.
   *
   * # Arguments
   * * `asset` - The trading asset/symbol (e.g., "EUR/USD")
   * * `period` - The historical data period
   *
   * # Returns
   * A JSON string containing the historical data
   *
   * # Examples
   * ```javascript
   * const history = await client.history("EUR/USD", 60);
   * const data = JSON.parse(history);
   * console.log(`Retrieved ${data.length} historical records`);
   * ```
   */
  history(asset: string, period: number): Promise<any>
  /**
   * Subscribes to real-time price updates for a symbol.
   *
   * # Arguments
   * * `symbol` - The trading symbol to subscribe to (e.g., "EUR/USD")
   *
   * # Returns
   * A StreamIterator for receiving price updates
   *
   * # Examples
   * ```javascript
   * const stream = await client.subscribeSymbol("EUR/USD");
   * for await (const update of stream) {
   *     console.log(`New price: ${update.price}`);
   * }
   * ```
   */
  subscribeSymbol(symbol: string): Promise<StreamIterator>
  /**
   * Subscribes to symbol updates with chunked delivery.
   *
   * # Arguments
   * * `symbol` - The trading symbol to subscribe to (e.g., "EUR/USD")
   * * `chunk_size` - Number of updates to collect before delivery
   *
   * # Returns
   * A StreamIterator for receiving chunked price updates
   *
   * # Examples
   * ```javascript
   * const stream = await client.subscribeSymbolChunked("EUR/USD", 10);
   * for await (const updates of stream) {
   *     console.log(`Received batch of ${updates.length} updates`);
   * }
   * ```
   */
  subscribeSymbolChunked(symbol: string, chunkSize: number): Promise<StreamIterator>
  /**
   * Subscribes to symbol updates with time-based delivery.
   *
   * # Arguments
   * * `symbol` - The trading symbol to subscribe to (e.g., "EUR/USD")
   * * `time_seconds` - Time interval in seconds between updates
   *
   * # Returns
   * A StreamIterator for receiving time-based price updates
   *
   * # Examples
   * ```javascript
   * const stream = await client.subscribeSymbolTimed("EUR/USD", 5);
   * for await (const update of stream) {
   *     console.log(`Update at ${new Date()}: ${update.price}`);
   * }
   * ```
   */
  subscribeSymbolTimed(symbol: string, timeSeconds: number): Promise<StreamIterator>
  /**
   * Sends a raw WebSocket message to the server.
   *
   * # Arguments
   * * `message` - The raw message string to send
   *
   * # Examples
   * ```javascript
   * await client.sendRawMessage(JSON.stringify({
   *     type: "custom_command",
   *     data: { / ... / }
   * }));
   * ```
   */
  sendRawMessage(message: string): Promise<void>
  /**
   * Creates a raw order with custom validation.
   *
   * # Arguments
   * * `message` - The raw order message
   * * `validator` - A validator instance for response validation
   *
   * # Returns
   * A JSON string containing the order result
   *
   * # Examples
   * ```javascript
   * const validator = new Validator();
   * const result = await client.createRawOrder(
   *     JSON.stringify({ / order details / }),
   *     validator
   * );
   * ```
   */
  createRawOrder(message: string, validator: Validator): Promise<string>
  /**
   * Creates a raw order with a timeout for response validation.
   *
   * # Arguments
   * * `message` - The raw order message to send
   * * `validator` - A validator instance for response validation
   * * `timeout` - Timeout duration in seconds
   *
   * # Returns
   * A JSON string containing the order result, or error if timeout is reached
   *
   * # Examples
   * ```javascript
   * const validator = new Validator();
   * const result = await client.createRawOrderWithTimeout(
   *     JSON.stringify({ / order details / }),
   *     validator,
   *     30 // 30 seconds timeout
   * );
   * ```
   */
  createRawOrderWithTimeout(message: string, validator: Validator, timeout: number): Promise<string>
  /**
   * Creates a raw order with timeout and automatic retry functionality.
   *
   * # Arguments
   * * `message` - The raw order message to send
   * * `validator` - A validator instance for response validation
   * * `timeout` - Timeout duration in seconds for each attempt
   *
   * # Returns
   * A JSON string containing the order result, or error if all retries fail
   *
   * # Examples
   * ```javascript
   * const validator = new Validator();
   * const result = await client.createRawOrderWithTimeoutAndRetry(
   *     JSON.stringify({ / order details / }),
   *     validator,
   *     15 // 15 seconds timeout per attempt
   * );
   * ```
   */
  createRawOrderWithTimeoutAndRetry(message: string, validator: Validator, timeout: number): Promise<string>
  /**
   * Creates an iterator for handling raw WebSocket messages with validation.
   *
   * # Arguments
   * * `message` - The initial message to send to establish the stream
   * * `validator` - A validator instance for filtering messages
   * * `timeout` - Optional timeout duration in seconds for the stream
   *
   * # Returns
   * A RawStreamIterator that yields validated messages
   *
   * # Examples
   * ```javascript
   * const validator = new Validator();
   * const stream = await client.createRawIterator(
   *     JSON.stringify({ / subscription details / }),
   *     validator,
   *     60 // Optional: 60 seconds timeout
   * );
   * for await (const message of stream) {
   *     console.log(`Received: ${message}`);
   * }
   * ```
   */
  createRawIterator(message: string, validator: Validator, timeout?: number | undefined | null): Promise<RawStreamIterator>
}
/**
 * A validator for WebSocket messages that provides various matching strategies.
 *
 * # Examples
 * ```javascript
 * const validator = new Validator();
 * const regexValidator = Validator.regex("^Hello");
 * const containsValidator = Validator.contains("World");
 *
 * console.log(validator.check("Hello World")); // true
 * cons-.log(regexValidator.check("Hello World")); // true
 * console.log(containsValidator.check("Hello World")); // true
 * ```
 */
export declare class Validator {
  /**
   * Creates a new empty validator that matches any message.
   *
   * # Examples
   * ```javascript
   * const validator = new Validator();
   * console.log(validator.check("any message")); // true
   * ```
   */
  constructor()
  /**
   * Creates a new regex validator that matches messages using a regular expression pattern.
   *
   * # Arguments
   * * `pattern` - A string containing a valid regular expression pattern
   *
   * # Examples
   * ```javascript
   * const validator = Validator.regex("^Hello\\s\\w+");
   * console.log(validator.check("Hello World")); // true
   * console.log(validator.check("Hi World")); // false
   * ```
   */
  static regex(pattern: string): Validator
  /**
   * Creates a new validator that checks if a message contains the specified pattern.
   *
   * # Arguments
   * * `pattern` - The substring to search for in the message
   *
   * # Examples
   * ```javascript
   * const validator = Validator.contains("World");
   * console.log(validator.check("Hello World")); // true
   * console.log(validator.check("Hello")); // false
   * ```
   */
  static contains(pattern: string): Validator
  /**
   * Creates a new validator that checks if a message starts with the specified pattern.
   *
   * # Arguments
   * * `pattern` - The prefix to match at the start of the message
   *
   * # Examples
   * ```javascript
   * const validator = Validator.starts_with("Hello");
   * console.log(validator.check("Hello World")); // true
   * console.log(validator.check("World Hello")); // false
   * ```
   */
  static startsWith(pattern: string): Validator
  /**
   * Creates a new validator that checks if a message ends with the specified pattern.
   *
   * # Arguments
   * * `pattern` - The suffix to match at the end of the message
   *
   * # Examples
   * ```javascript
   * const validator = Validator.ends_with("World");
   * console.log(validator.check("Hello World")); // true
   * console.log(validator.check("World Hello")); // false
   * ```
   */
  static endsWith(pattern: string): Validator
  /**
   * Creates a new validator that negates the result of another validator.
   *
   * # Arguments
   * * `validator` - The validator whose result should be negated
   *
   * # Examples
   * ```javascript
   * const contains = Validator.contains("World");
   * const notContains = Validator.ne(contains);
   * console.log(notContains.check("Hello Universe")); // true
   * console.log(notContains.check("Hello World")); // false
   * ```
   */
  static ne(validator: Validator): Validator
  /**
   * Creates a new validator that requires all provided validators to match.
   *
   * # Arguments
   * * `validators` - An array of validators that must all match for this validator to match
   *
   * # Examples
   * ```javascript
   * const startsHello = Validator.starts_with("Hello");
   * const endsWorld = Validator.ends_with("World");
   * const both = Validator.all([startsHello, endsWorld]);
   * console.log(both.check("Hello Beautiful World")); // true
   * console.log(both.check("Hello Universe")); // false
   * ```
   */
  static all(validators: Array<Validator>): Validator
  /**
   * Creates a new validator that requires at least one of the provided validators to match.
   *
   * # Arguments
   * * `validators` - An array of validators where at least one must match for this validator to match
   *
   * # Examples
   * ```javascript
   * const containsHello = Validator.contains("Hello");
   * const containsHi = Validator.contains("Hi");
   * const either = Validator.any([containsHello, containsHi]);
   * console.log(either.check("Hello World")); // true
   * console.log(either.check("Hi there")); // true
   * console.log(either.check("Hey there")); // false
   * ```
   */
  static any(validators: Array<Validator>): Validator
  /**
   * Checks if a message matches this validator's conditions.
   *
   * # Arguments
   * * `msg` - The message string to validate
   *
   * # Returns
   * * `true` if the message matches the validator's conditions
   * * `false` otherwise
   *
   * # Examples
   * ```javascript
   * const validator = Validator.contains("World");
   * console.log(validator.check("Hello World")); // true
   * console.log(validator.check("Hello Universe")); // false
   * ```
   */
  check(msg: string): boolean
}
/**
 * A custom logging layer that can be used to capture and process log messages.
 * Used in conjunction with `StreamLogsIterator` to receive log messages.
 *
 * # Examples
 * ```javascript
 * const { StreamLogsLayer, LogBuilder } = require('binary-options-tools');
 *
 * const builder = new LogBuilder();
 * const iterator = builder.createLogsIterator('DEBUG');
 * ```
 */
export declare class StreamLogsLayer { }
/**
 * Iterator for receiving log messages from a `StreamLogsLayer`.
 * Supports asynchronous iteration over log messages.
 *
 * # Examples
 * ```javascript
 * const iterator = builder.createLogsIterator('DEBUG');
 *
 * // Async iteration
 * for await (const log of iterator) {
 *     console.log('Received log:', log);
 * }
 * ```
 */
export declare class StreamLogsIterator {
  /**
   * Gets the next log message from the stream.
   *
   * # Returns
   * * A Promise that resolves to:
   *   * A string containing the next log message
   *   * null if the stream has ended
   * * Rejects with an error if the stream encounters an error
   *
   * # Examples
   * ```javascript
   * const iterator = builder.createLogsIterator('DEBUG');
   *
   * // Using async/await
   * try {
   *     while (true) {
   *         const log = await iterator.next();
   *         if (log === null) break;
   *         console.log('Log:', log);
   *     }
   * } catch (err) {
   *     console.error('Stream error:', err);
   * }
   * ```
   */
  next(): Promise<any | null>
}
/**
 * Builder pattern for configuring the logging system.
 * Allows adding multiple log outputs and configuring log levels.
 *
 * # Examples
 * ```javascript
 * const { LogBuilder } = require('binary-options-tools');
 *
 * const builder = new LogBuilder();
 * // Add file logging
 * builder.logFile('./app.log', 'INFO');
 * // Add terminal logging
 * builder.terminal('DEBUG');
 * // Create log stream
 * const iterator = builder.createLogsIterator('DEBUG');
 * // Initialize logging
 * builder.build();
 * ```
 */
export declare class LogBuilder {
  /**
   * Creates a new LogBuilder instance.
   *
   * # Examples
   * ```javascript
   * const { LogBuilder } = require('binary-options-tools');
   * const builder = new LogBuilder();
   * ```
   */
  constructor()
  /**
   * Creates a new logs iterator that receives log messages at the specified level.
   *
   * # Arguments
   * * `level` - Logging level ("DEBUG", "INFO", "WARN", "ERROR")
   * * `timeout` - Optional timeout in seconds after which the iterator will stop
   *
   * # Returns
   * * A StreamLogsIterator that can be used to receive log messages
   *
   * # Examples
   * ```javascript
   * const builder = new LogBuilder();
   *
   * // Create iterator with default DEBUG level
   * const iterator1 = builder.createLogsIterator('DEBUG');
   *
   * // Create iterator with INFO level and 60-second timeout
   * const iterator2 = builder.createLogsIterator('INFO', 60);
   * ```
   */
  createLogsIterator(level: string, timeout?: number | undefined | null): StreamLogsIterator
  /**
   * Adds a file output for logs at the specified level.
   *
   * # Arguments
   * * `path` - Path to the log file
   * * `level` - Logging level ("DEBUG", "INFO", "WARN", "ERROR")
   *
   * # Returns
   * * Result indicating success or failure
   *
   * # Examples
   * ```javascript
   * const builder = new LogBuilder();
   *
   * // Log INFO and above to app.log
   * builder.logFile('./app.log', 'INFO');
   *
   * // Log DEBUG and above to debug.log
   * builder.logFile('./debug.log', 'DEBUG');
   * ```
   */
  logFile(path: string, level: string): void
  /**
   * Adds terminal (console) output for logs at the specified level.
   *
   * # Arguments
   * * `level` - Logging level ("DEBUG", "INFO", "WARN", "ERROR")
   *
   * # Examples
   * ```javascript
   * const builder = new LogBuilder();
   *
   * // Show DEBUG and above in terminal
   * builder.terminal('DEBUG');
   *
   * // Show only INFO and above in terminal
   * builder.terminal('INFO');
   * ```
   */
  terminal(level: string): void
  /**
   * Finalizes the logging configuration and initializes the logging system.
   * Must be called after all outputs are configured and before logging begins.
   * Can only be called once per builder instance.
   *
   * # Returns
   * * Result indicating success or failure
   *
   * # Examples
   * ```javascript
   * const builder = new LogBuilder();
   * builder.logFile('./app.log', 'INFO');
   * builder.terminal('DEBUG');
   *
   * // Initialize logging system
   * builder.build();
   *
   * // Attempting to build again will result in an error
   * builder.build(); // Error: Builder has already been built
   * ```
   */
  build(): void
}
/**
 * Simple logging interface for emitting log messages at different levels.
 *
 * # Examples
 * ```javascript
 * const { Logger } = require('binary-options-tools');
 *
 * const logger = new Logger();
 * logger.debug('Debug message');
 * logger.info('Info message');
 * logger.warn('Warning message');
 * logger.error('Error message');
 * ```
 */
export declare class Logger {
  /**
   * Creates a new Logger instance.
   *
   * # Examples
   * ```javascript
   * const { Logger } = require('binary-options-tools');
   * const logger = new Logger();
   * ```
   */
  constructor()
  /**
   * Logs a debug message.
   * Only appears if logging level is set to DEBUG.
   *
   * # Arguments
   * * `message` - The message to log
   *
   * # Examples
   * ```javascript
   * const logger = new Logger();
   * logger.debug('Processing started');
   * logger.debug(`Current value: ${value}`);
   * ```
   */
  debug(message: string): void
  /**
   * Logs an info message.
   * Only appears if logging level is set to INFO or lower.
   *
   * # Arguments
   * * `message` - The message to log
   *
   * # Examples
   * ```javascript
   * const logger = new Logger();
   * logger.info('Operation completed successfully');
   * logger.info(`Processed ${count} items`);
   * ```
   */
  info(message: string): void
  /**
   * Logs a warning message.
   * Only appears if logging level is set to WARN or lower.
   *
   * # Arguments
   * * `message` - The message to log
   *
   * # Examples
   * ```javascript
   * const logger = new Logger();
   * logger.warn('Resource usage high');
   * logger.warn(`Retry attempt ${retryCount} of ${maxRetries}`);
   * ```
   */
  warn(message: string): void
  /**
   * Logs an error message.
   * Only appears if logging level is set to ERROR or lower.
   *
   * # Arguments
   * * `message` - The message to log
   *
   * # Examples
   * ```javascript
   * const logger = new Logger();
   * logger.error('Operation failed');
   * logger.error(`Failed to connect: ${error.message}`);
   * ```
   */
  error(message: string): void
}
